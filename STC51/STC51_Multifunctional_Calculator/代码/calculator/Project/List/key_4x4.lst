C51 COMPILER V9.60.7.0   KEY_4X4                                                           08/29/2025 11:40:49 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE KEY_4X4
OBJECT MODULE PLACED IN .\Output\key_4x4.obj
COMPILER INVOKED BY: C:\Users\Mr.chen\AppData\Local\Keil_v51\C51\BIN\C51.EXE ..\Source\key_4x4.c LARGE OPTIMIZE(8,SPEED)
                    - BROWSE INCDIR(..\Source;..\User) DEBUG OBJECTEXTEND PRINT(.\List\key_4x4.lst) TABS(2) OBJECT(.\Output\key_4x4.obj)

line level    source

   1          #include  "key_4x4.h"
   2          #include  "timer.h"
   3          
   4          
   5          /**************************************************************************************
   6           * 描  述 : 4x4矩阵扫描函数
   7           * 入  参 : 无
   8           * 返回值 : 哪个按键按下的对应值
   9           **************************************************************************************/
  10          uint8 KeyScan(void)
  11          {
  12   1          uint8 X_temp = 0xF0, Y_temp = 0x0F, temp;
  13   1          uint8 key_val = 0;
  14   1      
  15   1          // 行输出高，列输出低，检测行
  16   1          P2M1 &= 0x3F; P2M0 |= 0xC0;        // P2.6/P2.7推挽输出
  17   1          P4M1 &= 0x0F; P4M0 |= 0xF0;        // P4.4-P4.7推挽输出
  18   1          P5M1 &= 0xF3; P5M0 |= 0x0C;        // P5.2/P5.3推挽输出
  19   1      
  20   1          ROW1=1; ROW2=1; ROW3=1; ROW4=1;
  21   1          COL1=0; COL2=0; COL3=0; COL4=0;
  22   1      
  23   1          delay_ms(10);
  24   1          P4M1 &= 0x0F; P4M0 &= 0x0F;        // P4.4-P4.7改为输入
  25   1          delay_ms(10);
  26   1      
  27   1          if(ROW1 == 0) {delay_ms(10); if(ROW1 == 0) Y_temp &= 0x0E;}
  28   1          if(ROW2 == 0) {delay_ms(10); if(ROW2 == 0) Y_temp &= 0x0D;}
  29   1          if(ROW3 == 0) {delay_ms(10); if(ROW3 == 0) Y_temp &= 0x0B;}
  30   1          if(ROW4 == 0) {delay_ms(10); if(ROW4 == 0) Y_temp &= 0x07;}
  31   1      
  32   1          // 列输出高，行输出低，检测列
  33   1          P2M1 &= 0x3F; P2M0 |= 0xC0;
  34   1          P4M1 &= 0x0F; P4M0 |= 0xF0;
  35   1          P5M1 &= 0xF3; P5M0 |= 0x0C;
  36   1      
  37   1          ROW1=0; ROW2=0; ROW3=0; ROW4=0;
  38   1          COL1=1; COL2=1; COL3=1; COL4=1;
  39   1      
  40   1          delay_ms(10);
  41   1          P2M1 &= 0x3F; P2M0 &= 0x3F;        // P2.6/P2.7改为输入
  42   1          P5M1 &= 0xF3; P5M0 &= 0xF3;        // P5.2/P5.3改为输入
  43   1          delay_ms(10);
  44   1      
  45   1          if(COL1 == 0) {delay_ms(10); if(COL1 == 0) X_temp &= 0xE0;}
  46   1          if(COL2 == 0) {delay_ms(10); if(COL2 == 0) X_temp &= 0xD0;}
  47   1          if(COL3 == 0) {delay_ms(10); if(COL3 == 0) X_temp &= 0xB0;}
  48   1          if(COL4 == 0) {delay_ms(10); if(COL4 == 0) X_temp &= 0x70;}
  49   1      
  50   1          // 计算按键值
  51   1          temp = X_temp | Y_temp;
  52   1          temp = ~temp;
  53   1          switch(temp)
  54   1          {
C51 COMPILER V9.60.7.0   KEY_4X4                                                           08/29/2025 11:40:49 PAGE 2   

  55   2              case 0x11: key_val=1; break;    //1
  56   2              case 0x21: key_val=2; break;    //2    
  57   2              case 0x41: key_val=3; break;    //3
  58   2              case 0x81: key_val=4; break;    //4
  59   2              case 0x12: key_val=5; break;    //5
  60   2              case 0x22: key_val=6; break;    //6
  61   2              case 0x42: key_val=7; break;    //7
  62   2              case 0x82: key_val=8; break;    //8
  63   2              case 0x14: key_val=9; break;    //9
  64   2              case 0x24: key_val=10; break;   //0
  65   2              case 0x44: key_val=11; break;   //+
  66   2              case 0x84: key_val=12; break;   //-
  67   2              case 0x18: key_val=13; break;   //*
  68   2              case 0x28: key_val=14; break;   //=
  69   2              case 0x48: key_val=15; break;   //AC
  70   2              case 0x88: key_val=16; break;   //÷
  71   2              default: key_val=0; break;
  72   2          }
  73   1      
  74   1          return key_val;  // 直接返回按键值
  75   1      }
  76          /*********************************END FILE********************************************/ 
  77          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    491    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
