C51 COMPILER V9.60.7.0   LCD12864                                                          08/29/2025 10:06:05 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LCD12864
OBJECT MODULE PLACED IN .\Output\lcd12864.obj
COMPILER INVOKED BY: C:\Users\Mr.chen\AppData\Local\Keil_v51\C51\BIN\C51.EXE ..\Source\lcd12864.c LARGE OPTIMIZE(8,SPEED
                    -) BROWSE INCDIR(..\Source;..\User) DEBUG OBJECTEXTEND PRINT(.\List\lcd12864.lst) TABS(2) OBJECT(.\Output\lcd12864.obj)

line level    source

   1          #include "lcd12864.h" 
   2          
   3           /***************************************************************************
   4           * 描  述 : LCD12864液晶判忙子程序(读状态)
   5           * 入  参 : 无
   6           * 返回值 : 无
   7           * 备  注 : 若LCD为“忙”状态，一直等待直到LCD空闲
   8           **************************************************************************/
   9          void Busy(void)   
  10          {   
  11   1        uint8 busy;
  12   1        do  
  13   1        {  
  14   2          //读数据        
  15   2          lcd12864_RW = 1;          //并行的读/写选择信号：1为读,0为写    
  16   2          lcd12864_RS = 0;          //并行的指令/数据选择信号：1为数据,0为指令      
  17   2          lcd12864_E = 1;           //并行的使能信号：0=关闭使能端,1=打开使能端
  18   2          
  19   2          P0M1=0x00;  P0M0=0x00;    //设置P0.0~P0.7为准双向口   
  20   2          busy=P0;                  //读取P0端口数据 
  21   2          delay_us(100);        
  22   2          lcd12864_E = 0;           //并行的使能信号：0=关闭使能端,1=打开使能端     
  23   2        }while(busy&0x80);          //判断BUSY位是否工作:1为内部在工作,0为正常状态 
  24   1      }  
  25          
  26          /***************************************************************************
  27           * 描  述 : LCD12864液晶模块从当前地址读RAM数据
  28           * 参  数 : 无
  29           * 返回值 : Data：读取的数据
  30           **************************************************************************/
  31          uint8 Read_Data(void)
  32          {
  33   1        uint8 Data;
  34   1        
  35   1        P0 = 0xFF;                //P0端口赋值0xFF
  36   1        Busy();                   //判忙LCD12864液晶  （设置P0.0~P0.7为准双向口）
  37   1        
  38   1        //读指令     
  39   1        lcd12864_RW = 1;          //并行的读/写选择信号：1为读,0为写 
  40   1        lcd12864_RS = 1;          //并行的指令/数据选择信号：1为数据,0为指令    
  41   1        lcd12864_E = 1;           //并行的使能信号：0=关闭使能端,1=打开使能端 
  42   1        
  43   1        Data=P0;                  //保存读取的数据
  44   1        delay_us(10);     
  45   1        lcd12864_E = 0;           //并行的使能信号：0=关闭使能端,1=打开使能端    
  46   1        delay_us(10); 
  47   1        return Data;
  48   1      }
  49          
  50          /***************************************************************************
  51           * 描  述 : LCD12864液晶命令写入程序 
  52           * 参  数 :  uint8 cmd：写入的命令
  53           * 返回值 : 无
  54           **************************************************************************/
C51 COMPILER V9.60.7.0   LCD12864                                                          08/29/2025 10:06:05 PAGE 2   

  55          void Write_Cmd(uint8 cmd) 
  56          {      
  57   1        Busy();                   //判忙LCD12864液晶  （设置P0.0~P0.7为准双向口）
  58   1        
  59   1        //写指令     
  60   1        lcd12864_RW = 0;          //并行的读/写选择信号：1为读,0为写 
  61   1        lcd12864_RS = 0;          //并行的指令/数据选择信号：1为数据,0为指令  
  62   1      
  63   1        P0M1=0x00;  P0M0=0xFF;    //设置P0.0~P0.7为推挽输出
  64   1        P0=cmd;                   //写入命令 
  65   1        
  66   1        lcd12864_E = 1;           //并行的使能信号：0=关闭使能端,1=打开使能端 
  67   1        delay_us(10); 
  68   1        lcd12864_E = 0;           //并行的使能信号：0=关闭使能端,1=打开使能端    
  69   1        delay_us(10);   
  70   1      }
  71          
  72          /***************************************************************************
  73           * 描  述 : LCD12864液晶数据写入程序 
  74           * 参  数 : uint8 dat：写入的数据
  75           * 返回值 : 无
  76           **************************************************************************/
  77          void Write_Data(uint8 dat) 
  78          {      
  79   1        Busy();                   //判忙LCD12864液晶  （设置P0.0~P0.7为准双向口）
  80   1        
  81   1        //写数据     
  82   1        lcd12864_RW = 0;          //并行的读/写选择信号：1为读,0为写 
  83   1        lcd12864_RS = 1;          //并行的指令/数据选择信号：1为数据,0为指令  
  84   1      
  85   1        P0M1=0x00;  P0M0=0xFF;    //设置P0.0~P0.7为推挽输出
  86   1        P0=dat;                   //写入数据
  87   1        
  88   1        lcd12864_E = 1;           //并行的使能信号：0=关闭使能端,1=打开使能端 
  89   1        delay_us(30); 
  90   1        lcd12864_E = 0;           //并行的使能信号：0=关闭使能端,1=打开使能端 
  91   1      }  
  92          
  93          /**************************************************************************
  94           * 描  述 : 指定位置显示单个字符
  95           * 参  数 : row[in]:行，范围1~4
  96           *        ：column[in]:列，范围0~7  
  97           *        ：chr[in]:字符编码
  98           * 返回值 : 无
  99           **************************************************************************/
 100          void LCD_ShowChar(uint8 row,uint8 column,uint8 chr)
 101          {       
 102   1        uint8 Address; 
 103   1        
 104   1        //row判断第几行,column判断第几列,0x80为液晶行初始地址   
 105   1        if(row == 1)Address=0x80+column;   
 106   1        if(row == 2){Address=0x90+column;}        
 107   1        if(row == 3){Address=0x88+column;}    
 108   1        if(row == 4){Address=0x98+column;}  
 109   1        Write_Cmd(Address);  //写入地址命令到LCD12864     
 110   1        Write_Data(chr);     //写入显示数据到LCD12864    
 111   1      }
 112          
 113          /***************************************************************************
 114           * 描  述 : 字符串显示 
 115           * 参  数 : row[in]:行，范围1~4
 116           *        ：column[in]:列，范围0~7  
C51 COMPILER V9.60.7.0   LCD12864                                                          08/29/2025 10:06:05 PAGE 3   

 117           *        ：num[in]:字符个数，注意一个汉字=2个字符
 118           *        ：s[in]:指向待显示的字符串
 119           * 返回值 : 无
 120           **************************************************************************/
 121          void LCD_ShowString(uint8 row,uint8 column,uint8 num,uint8 *s)   
 122          {     
 123   1        uint8 Address;    
 124   1        
 125   1        //row判断第几行,column判断第几列,0x80为液晶行初始地址   
 126   1        if(row == 1)Address=0x80+column;   
 127   1        if(row == 2){Address=0x90+column;}        
 128   1        if(row == 3){Address=0x88+column;}    
 129   1        if(row == 4){Address=0x98+column;}   
 130   1        Write_Cmd(Address);    //写入显示起始地址
 131   1        while(num)             //写入显示数据的大小  
 132   1        {    
 133   2          Write_Data(*(s++));  //写入显示数据到LCD12864    
 134   2          num--;         
 135   2        }   
 136   1      } 
 137          
 138          /***************************************************************************
 139           * 描  述 : 填充，当如数数据为0的时候即可实现清屏
 140           * 参  数 : uint8 dat：填充的数据
 141           * 返回值 : 无
 142          **************************************************************************/
 143          void Fill_GDRAM(uint8 dat)
 144          {
 145   1        uint8 i,j,k;
 146   1      
 147   1        uint8 GDRAM_X=0x80;
 148   1        uint8 GDRAM_Y=0x80;
 149   1      
 150   1        for(i=0;i<2;i++)
 151   1        {
 152   2          for(j=0;j<32;j++)
 153   2          {
 154   3            for(k=0;k<8;k++)
 155   3            {
 156   4              Write_Cmd(0x34);
 157   4              Write_Cmd(GDRAM_Y+j);
 158   4              Write_Cmd(GDRAM_X+k);
 159   4              Write_Data(dat);
 160   4              Write_Data(dat);
 161   4            }
 162   3          }
 163   2          GDRAM_X=0x88;
 164   2        }
 165   1      
 166   1        Write_Cmd(DRAM_ON);   //开启绘图模式
 167   1        Write_Cmd(0x30);      //恢复基本指令集，关闭绘图模式
 168   1      }
 169          
 170          /**************************************************************************
 171           * 描  述 : LCD12864液晶任意位置画点
 172           * 参  数 : x[in]:x坐标，范围0~127
 173           *        ：y[in]:y坐标，范围0~63  
 174           *        ：color[in]:0=熄灭，1=点亮，2=反显
 175           * 返回值 : 无
 176           **************************************************************************/
 177          void LCD_DrawDot(uint8 x,uint8 y,uint8 color)
 178          {
C51 COMPILER V9.60.7.0   LCD12864                                                          08/29/2025 10:06:05 PAGE 4   

 179   1        uint8 row,columu,x_byte,x_bit; 
 180   1        uint8 Read_H=0,Read_L=0;  
 181   1        
 182   1        Write_Cmd(0x34);  //使用扩展指令集 
 183   1        Write_Cmd(0x36);  //绘图显示开     
 184   1        
 185   1        //X轴一次操作对应16个位(2个字节)，所以要计算画的点属于哪个字节、在字节中属于哪个位
 186   1        x_byte = x>>4;    //计算将要画的点属于哪一个字节     
 187   1        x_bit  = x & 0x0F;//计算将要画的点属于哪一个位 
 188   1        
 189   1        //GDRAM将屏幕划分为上半屏和下半屏，在上半屏和下半屏中Y轴的坐标都是从0~31，所以要根据输入的
 190   1        //直角坐标计算出改点属于上半屏还是下半屏
 191   1        if(y < 32) {columu = x_byte,row=y;} //该点位于上半屏
 192   1        else              //该点位于下半屏 
 193   1        {         
 194   2          row = y-32;         
 195   2          columu = x_byte + 8;     
 196   2        } 
 197   1        Write_Cmd(row+0x80);       //写入行地址
 198   1        Write_Cmd(columu+0x80);    //写入列地址
 199   1        Read_Data();               //假读
 200   1        Read_H=Read_Data();        //读出将要写入的地址的数据，这样做是为了不影响屏幕上其他点的显示
 201   1        Read_L=Read_Data();   
 202   1        
 203   1        //读的时候地址会自动增加，所以要重新写一下地址
 204   1        Write_Cmd(row+0x80);
 205   1        Write_Cmd(columu+0x80);   
 206   1        if(x_bit < 8)
 207   1        {
 208   2          switch(color)
 209   2          {
 210   3             case 0:Read_H &=(~(0x01<<(7-x_bit))); break; 
 211   3             case 1:Read_H |=(0x01<<(7-x_bit)); break;
 212   3             case 2:Read_H ^=(0x01<<(7-x_bit)); break; 
 213   3             default:break;
 214   3          } 
 215   2        }
 216   1        else
 217   1        {
 218   2          switch(color)
 219   2          {
 220   3             case 0:Read_L &=(~(0x01<<(15-x_bit))); break;
 221   3             case 1:Read_L |=(0x01<<(15-x_bit)); break; 
 222   3             case 2:Read_L ^=(0x01<<(15-x_bit)); break; 
 223   3             default:break;
 224   3          } 
 225   2        }
 226   1      
 227   1        //写入数据  
 228   1        Write_Data(Read_H);
 229   1        Write_Data(Read_L);
 230   1        Write_Cmd(0x30);//恢复基本指令集，关闭绘图模式
 231   1      }
 232          
 233          /**************************************************************************
 234           * 描  述 : LCD12864液晶画水平直线
 235           * 参  数 : x0[in]:起点x轴坐标，范围0~127
 236           *        : x1[in]:终点x轴坐标，范围0~127
 237           *        ：y[in]:y轴坐标，范围0~63  
 238           *        ：color[in]:0=熄灭，1=点亮，2=反显
 239           * 返回值 : SUCESS：操作程序。 PARM_ERR：输入参数错误
 240           **************************************************************************/
C51 COMPILER V9.60.7.0   LCD12864                                                          08/29/2025 10:06:05 PAGE 5   

 241          uint8 DrawHline(uint8 x0,uint8 x1,uint8 y,uint8 color)
 242          { 
 243   1        uint8 temp;
 244   1        
 245   1        //判断输入参数是否合法
 246   1        if((x0>127)||(x1>127)||(y>63))return PARM_ERR;
 247   1        if(color>2)return PARM_ERR;
 248   1      
 249   1        if(x0>x1)
 250   1        {
 251   2          temp=x0;x0=x1;
 252   2          x1=temp;
 253   2        } 
 254   1        do
 255   1        { 
 256   2          LCD_DrawDot(x0,y,color);
 257   2          x0++; 
 258   2        }
 259   1        while(x1>=x0);
 260   1        
 261   1        return SUCESS;
 262   1      }
 263          
 264          /**************************************************************************
 265           * 描  述 : LCD12864液晶画垂直直线
 266           * 参  数 : x[in]:x轴坐标，范围0~127
 267           *        : y0[in]:y轴起点坐标，范围0~63
 268           *        ：y1[in]:y轴终点坐标，范围0~63  
 269           *        ：color[in]:0=熄灭，1=点亮，2=反显
 270           * 返回值 : SUCESS：操作程序。 PARM_ERR：输入参数错误
 271           **************************************************************************/
 272          uint8 DrawVline(uint8 x,uint8 y0,uint8 y1,uint8 color)
 273          { 
 274   1        uint8 temp;
 275   1        
 276   1        //判断输入参数是否合法
 277   1        if((x>127)||(y0>63)||(y1>63))return PARM_ERR;
 278   1        if(color>2)return PARM_ERR;
 279   1        if(y0>y1)
 280   1        { 
 281   2          temp=y0;y1=y0;y0=temp;
 282   2        }
 283   1        do
 284   1        { 
 285   2          LCD_DrawDot(x,y0,color);
 286   2          y0++; 
 287   2        }
 288   1        while(y1>=y0);
 289   1        
 290   1        return SUCESS;
 291   1      }
 292          
 293          /**************************************************************************
 294           * 描  述 : LCD12864液晶画任意直线
 295           * 参  数 : x0[in]:x轴起点坐标，范围0~127
 296           *        : x1[in]:x轴终点坐标，范围0~127
 297           *        : y0[in]:y轴起点坐标，范围0~63
 298           *        ：y1[in]:y轴终点坐标，范围0~63  
 299           *        ：color[in]:0=熄灭，1=点亮，2=反显
 300           * 返回值 : 无
 301           **************************************************************************/
 302          uint8 DrawLine(uint8 x0,uint8 y0,uint8 x1,uint8 y1,uint8 color)
C51 COMPILER V9.60.7.0   LCD12864                                                          08/29/2025 10:06:05 PAGE 6   

 303          {
 304   1        uint16 i,distance;  
 305   1        uint16 x=0,y=0,dx,dy;
 306   1        uint8 incx,incy;
 307   1      
 308   1        dx=x1-x0;  //计算x轴的增量
 309   1        dy=y1-y0;  //计算y轴的增量
 310   1       
 311   1        if(dx > 0)incx=1;
 312   1        else if(dx == 0)
 313   1        { 
 314   2          //x轴起点和终点相等，表示画垂直直线
 315   2          DrawVline(x0,y0,y1,color);
 316   2          return SUCESS;
 317   2        }
 318   1        else incx=-1;
 319   1        
 320   1        if(dy > 0)incy=1;
 321   1        else if(dy == 0)
 322   1        { 
 323   2          //y轴起点和终点相等，表示画水平直线
 324   2          DrawHline(x0,y0,y1,color);
 325   2          return SUCESS;
 326   2        }
 327   1        else incy=-1;
 328   1        
 329   1        //取dx,dy绝对值
 330   1        dx=abs(dx);
 331   1        dy=abs(dy);
 332   1        //角度变换，确保角度<=45°
 333   1        if(dx > dy)distance=dx;
 334   1        else distance=dy;
 335   1        
 336   1        //开始绘制直线
 337   1        for(i=0;i<=distance+1;i++)
 338   1        {
 339   2          LCD_DrawDot(x0,y0,color);
 340   2          x+=dx;
 341   2          y+=dy;
 342   2          if(x>distance)
 343   2          {
 344   3            x-=distance;
 345   3            x0+=incx;
 346   3          }
 347   2          if(y>distance)
 348   2          {
 349   3            y-=distance;
 350   3            y0+=incy;
 351   3          }
 352   2        }
 353   1        return SUCESS;
 354   1      }
 355          
 356          /***************************************************************************
 357           * 描  述 : 显示图片128×64
 358           * 参  数 : uint8 *bmp：图片
 359           * 返回值 : 无
 360          **************************************************************************/
 361          void DrawBMP(uint8 *bmp)  
 362          { 
 363   1        uint8 i,j;
 364   1      
C51 COMPILER V9.60.7.0   LCD12864                                                          08/29/2025 10:06:05 PAGE 7   

 365   1        Write_Cmd(DRAM_OFF);        //写数据时,关闭图形显示
 366   1      
 367   1        for(i=0;i<32;i++)
 368   1        {
 369   2          Write_Cmd(0x80+i);        //先写入水平坐标值
 370   2          Write_Cmd(0x80);          //写入垂直坐标值
 371   2          for(j=0;j<16;j++)         //再写入两个8位元的数据    
 372   2          Write_Data(*bmp++);     
 373   2          delay_us(30); 
 374   2        }
 375   1      
 376   1        for(i=0;i<32;i++)
 377   1        { 
 378   2          Write_Cmd(0x80+i);
 379   2          Write_Cmd(0x88);
 380   2          for(j=0;j<16;j++)         
 381   2          Write_Data(*bmp++);    
 382   2          delay_us(30); 
 383   2        }
 384   1        Write_Cmd(DRAM_ON);       //写完数据,开图形显示 
 385   1      }
 386          
 387           /***************************************************************************
 388           * 描  述 : LCD12864液晶初始化子程序 
 389           * 入  参 : 无
 390           * 返回值 : 无
 391           **************************************************************************/
 392           void LCD_Init(void)     
 393           {   
 394   1         lcd12864_E = 0;    //关闭LCD12864模块使能端
 395   1         delay_ms(1);                  
 396   1         Write_Cmd(0x30);   //基本指令集     
 397   1         delay_ms(1);      
 398   1         Write_Cmd(0x02);   // 地址归位     
 399   1         delay_ms(1);      
 400   1         Write_Cmd(0x0c);   //整体显示打开,游标关闭     
 401   1         delay_ms(1);      
 402   1         Write_Cmd(0x06);   //游标右移     
 403   1         delay_ms(1);      
 404   1         Write_Cmd(0x80);   //设定显示的起始地址     
 405   1         delay_ms(1);      
 406   1         Write_Cmd(0x01);   //清除显示
 407   1         delay_ms(10);      // 这个延时必须要有，否则可能会出现花屏  
 408   1       }
 409          
 410          /*********************************END FILE********************************************/ 
 411          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1660    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      59
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
